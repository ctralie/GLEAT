<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!--External Libraries!-->
<!--<script type="text/javascript" src="js/gl-matrix.js"></script>!-->
<script type="text/javascript" src = "js/gl-matrix-min.js"></script>
<script type="text/javascript" src="js/webgl-utils.js"></script>
<script type="text/javascript" src="js/numeric-1.2.6.min.js"></script>
<script type="text/javascript" src="js/jquery-1.11.1.min.js"></script>

<!--Our Scripts!-->
<script src="Geometry/PolyMesh.js"></script>
<script src="Geometry/Primitives3D.js"></script>
<script src="Geometry/Cameras3D.js"></script>
<script src="Shaders/Shaders.js"></script>
</head>

<body>

<table>
<tr><td><h3>Mesh File</h3></td><td><input type = "file" id = "meshInput"></td></tr>
</table>
<canvas id="MainGLCanvas" style="border: none;" width="800" height="600"></canvas>


<script>
	var gl;
	var glcanvas = document.getElementById("MainGLCanvas");
	var lastX;
	var lastY;
	var dragging = false;
	var justClicked = false;
	var camera = new MousePolarCamera(glcanvas.width, glcanvas.height, 0.75);
	var mesh = PolyMesh();
	
	//Lighting info
	var ambientColor = vec3.fromValues(0.1, 0.1, 0.1);
	var lightingDirection = vec3.fromValues(0, 0, 1);
	var directionalColor = vec3.fromValues(0.5, 0.5, 0.5);
	
	/////////////////////////////////////////////////////
	//Step 1: Setup repaint function
	/////////////////////////////////////////////////////	
	function repaint() {
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		var pMatrix = mat4.create();
		mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, camera.R/100.0, camera.R*2);
		var mvMatrix = camera.getMVMatrix();	
		mesh.render(colorShader, pMatrix, mvMatrix, ambientColor, lightingDirection, directionalColor);		
	}	
	
	/////////////////////////////////////////////////////
	//Step 2: Setup mouse callbacks
	/////////////////////////////////////////////////////
	function getMousePos(evt) {
		var rect = glcanvas.getBoundingClientRect();
		return {
		    X: evt.clientX - rect.left,
		    Y: evt.clientY - rect.top
		};
	}
	function releaseClick(evt) {
		evt.preventDefault();
		dragging = false;
		return false;
	} 

	function makeClick(evt) {
		evt.preventDefault();
		dragging = true;
		justClicked = true;
		var mousePos = getMousePos(evt);
		lastX = mousePos.X;
		lastY = mousePos.Y;
		return false;
	} 

	//http://www.w3schools.com/jsref/dom_obj_event.asp
	function clickerDragged(evt) {
		evt.preventDefault();
		var mousePos = getMousePos(evt);
		var dX = mousePos.X - lastX;
		var dY = mousePos.Y - lastY;
		lastX = mousePos.X;
		lastY = mousePos.Y;
		if (dragging) {
			//Translate/rotate shape
			if (evt.button() == 1) { //Center click
				camera.translate(dX, dY);
			}
			else if (evt.button() == 2) { //Right click
				camera.zoom(-dY); //Want to zoom in as the mouse goes up
			}
			else if (evt.button() == 0) {
				this.camera.orbitLeftRight(dX);
				this.camera.orbitUpDown(dY);
			}
		    requestAnimFrame(repaint);
		}
		return false;
	}	
	
	/////////////////////////////////////////////////////
	//Step 3: Initialize offscreen rendering for picking
	/////////////////////////////////////////////////////
	//https://github.com/gpjt/webgl-lessons/blob/master/lesson16/index.html
	var pickingFramebuffer;
	var pickingTexture;
	function initPickingFramebuffer(canvas) {
		pickingFramebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, pickingFramebuffer);
		pickingFramebuffer.width = canvas.width;
		pickingFramebuffer.height = canvas.height;
		pickingTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, pickingTexture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pickingFramebuffer.width, pickingFramebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		var renderbuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, pickingFramebuffer.width, pickingFramebuffer.height);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	}
	
	/////////////////////////////////////////////////////
	//Step 4: Initialize Web GL
	/////////////////////////////////////////////////////
	glcanvas.addEventListener('mousedown', makeClick);
	glcanvas.addEventListener('mouseup', releaseClick);
	glcanvas.addEventListener('mousemove', clickerDragged);

	//Support for mobile devices
	glcanvas.addEventListener('touchstart', makeClick);
	glcanvas.addEventListener('touchend', releaseClick);
	glcanvas.addEventListener('touchmove', clickerDragged);

	try {
	    gl = glcanvas.getContext("experimental-webgl");
	    gl.viewportWidth = glcanvas.width;
	    gl.viewportHeight = glcanvas.height;
	} catch (e) {
		console.log(e);
	}
	if (!gl) {
	    alert("Could not initialise WebGL, sorry :-(.  Try a new version of chrome or firefox and make sure your newest graphics drivers are installed");
	}
	initShaders(gl);
	initPickingFramebuffer(glcanvas);

	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	
	gl.useProgram(colorShader);	

	/////////////////////////////////////////////////////
	//Step 5: Setup mesh input
	/////////////////////////////////////////////////////
	var meshInput = document.getElementById('meshInput');
	var result = document.getElementById('text');
	
	meshInput.addEventListener('change', function(e) {
		var file = meshInput.files[0];
		var textType = /text.*/;
		
		if (file.type.match(textType) || file.type == "model/x-geomview-off") {
			var reader = new FileReader();
			reader.onload = function(e) {
				var lines = reader.result.split("\n");
				mesh.loadFile(lines);
				if (mesh.vertexBuffer === null) {
					mesh.initBuffers(gl);
				}
				camera.centerOnMesh(mesh);
				requestAnimFrame(repaint);
			}
			reader.readAsText(file);	
		} else {
			console.log("File type not supported for mesh!  Expecting text or OFF file");
		}
	});
</script>

</body>
</html>
